<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rsync同步文件</title>
    <url>/2023/11/10/Rsync%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>Rsync常用的一款同步文件工具。配置也很方便。</p>
<p>&nbsp;</p>
<p>yum install sync -y或者apt-get install sync</p>
<ul>
<li>服务安装好之后，/etc下没有配置文件，一般情况可以copy示例文件到/etc下</li>
</ul>
<p>&nbsp;</p>
<p>#cp&nbsp;/usr/share/doc/rsync/examples/rsyncd.conf&nbsp;/etc</p>
<p>&nbsp;</p>
<p>vim /etc/rsyncd.conf</p>
<p>uid = common</p>
<p>gid = common</p>
<p>use chroot = no</p>
<p>max connections = 10</p>
<p>strict modes = yes</p>
<p>hosts allow = 192.168.2.12&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #可以空格，允许多个</p>
<p>hosts deny = *</p>
<p>port = 5699&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#默认开启端口</p>
<p>pid file = /var/run/rsyncd.pid</p>
<p>lock file = /var/run/rsync.lock</p>
<p>log file = /var/log/rsyncd.log</p>
<p>[hmt]</p>
<p>path = /data/www/html/</p>
<p>comment = hello</p>
<p>ignore errors</p>
<p>read only = no</p>
<p>write only = no</p>
<p>hosts allow = 192.168.2.12&nbsp;</p>
<p>list = false</p>
<p>auth users = hmt</p>
<p>secrets file = /etc/rsync.password</p>
<ul>
<li>建立/etc/rsyncd/rsyncd.secrets文件</li>
</ul>
<p>#vim /etc/rsync.password</p>
<p>#cat /etc/rsyncd/rsyncd.secrets</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;hmt:123456</p>
<ul>
<li>为了密码的安全性，我们必须把权限设为600</li>
</ul>
<h1 id="chown-root-root-etc-rsyncd-rsyncd-secrets"><a href="#chown-root-root-etc-rsyncd-rsyncd-secrets" class="headerlink" title="chown root:root /etc/rsyncd/rsyncd.secrets"></a>chown root:root /etc/rsyncd/rsyncd.secrets</h1><p>chmod 600&nbsp;&nbsp;/etc/rsync.password</p>
<h1 id="chmod-600-etc-rsyncd-rsyncd-secrets"><a href="#chmod-600-etc-rsyncd-rsyncd-secrets" class="headerlink" title="chmod 600&nbsp;/etc/rsyncd/rsyncd.secrets"></a>chmod 600&nbsp;/etc/rsyncd/rsyncd.secrets</h1><h1 id="vim-etc-rsyncd-rsyncd-motd"><a href="#vim-etc-rsyncd-rsyncd-motd" class="headerlink" title="vim /etc/rsyncd/rsyncd.motd"></a>vim /etc/rsyncd/rsyncd.motd</h1><p>&nbsp;</p>
<p>启动rsync：</p>
<p>systemctl start rsyncd.service</p>
<p>&nbsp;lsof -i:5699</p>
<p>lsof -i:5699</p>
<p>COMMAND PID USER&nbsp; &nbsp;FD&nbsp; &nbsp;TYPE&nbsp; &nbsp;DEVICE SIZE/OFF NODE NAME</p>
<p>rsync&nbsp; &nbsp;750 root&nbsp; &nbsp; 4u&nbsp; IPv4 22661487&nbsp; &nbsp; &nbsp; 0t0&nbsp; TCP *:5699 (LISTEN)</p>
<p>rsync&nbsp; &nbsp;750 root&nbsp; &nbsp; 5u&nbsp; IPv6 22661488&nbsp; &nbsp; &nbsp; 0t0&nbsp; TCP *:5699 (LISTEN)</p>
<p>至此服务器端安装完毕；</p>
<p>客户端安装配置：</p>
<p>&nbsp;</p>
<p>yum -y install rsync</p>
<p>&nbsp;客户端需要vim&nbsp;/etc/rsync.password&nbsp;</p>
<p>cat&nbsp;&nbsp;/etc/rsync.password</p>
<p>123456</p>
<p>运行：</p>
<p>rsync -avz –port 5699 –password-file=/etc/rsync.password <a href="mailto:hmt@192.168.2.12">hmt@192.168.2.12</a>::hmt&nbsp; /data/www/html</p>
<p>Password: 这里要输入rsync的密码，是服务器端提供的，在前面的例子中，我们用的是 asdf，输入的密码并不显示出来；输好后就回车；&nbsp;注：&nbsp;这个命令的意思就是说，用rsync 用户登录到服务器上，把/data/www/html&nbsp;数据，同步到本地目录/data/www/html/上。当然本地的目录是可以你自己定义的，比如 dave也是可以的；当你在客户端上，当前操作的目录下没有/tmp/test/这个目录时，系统会自动为你创建一个；当存在/tmp/test/这个目录中，你要注意它的写权限。</p>
<p>参数说明：</p>
<p>&nbsp;-a 参数，相当于-rlptgoD，</p>
<p>&nbsp;&nbsp;&nbsp;-r 是递归 -l 是链接文件，意思是拷贝链接文件；</p>
<p>&nbsp;&nbsp;&nbsp;-p 表示保持文件原有权限；</p>
<p>&nbsp;&nbsp;&nbsp;-t 保持文件原有时间；<br>&nbsp;&nbsp;&nbsp;-g 保持文件原有用户组；</p>
<p>&nbsp;&nbsp;&nbsp;-o 保持文件原有属主；</p>
<p>&nbsp;&nbsp;&nbsp;-D 相当于块设备文件；</p>
<p>&nbsp;&nbsp;&nbsp;-z 传输时压缩；</p>
<p>&nbsp;&nbsp;&nbsp;-P 传输进度；</p>
<p>&nbsp;&nbsp;&nbsp;-v 传输时的进度等信息，和-P有点关系</p>
<p>&nbsp;<br>*</p>
<p>rsync -avzP &nbsp;–delete <a href="mailto:rsync@192.168.2.150">rsync@192.168.2.150</a>::hometools&nbsp;/tmp/test/</p>
<p>–delete 选项，表示服务器上的数据要与客户端完全一致，如果 /tmp/test/目录中有服务器上不存在的文件，则删除。最终目的是让/tmp/test/目录上的数据完全与服务器上保持一致；用的时候要小心点，最好不要把已经有重要数所据的目录，当做本地更新目录，否则会把你的数据全部删除；
&nbsp;</p>
<p>计划任务同步：</p>
<p>*/5 * * * * rsync -zvaP <a href="mailto:rsync@192.168.2.150">rsync@192.168.2.150</a>::hometools /tmp/test/ –password-file=/etc/rsyncd/rsyncd.secrets</p>
<p>*/5 * * * * rsync -avz –port 5699 –password-file=/etc/rsync.password <a href="mailto:hmt@192.168.2.12">hmt@192.168.2.12</a>::hmt&nbsp; /data/www/html</p>
<p>&nbsp;</p>
]]></content>
  </entry>
  <entry>
    <title>zabbix监控业务进程变动</title>
    <url>/2023/11/13/Zabbix_%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E5%AE%95%E6%9C%BA/</url>
    <content><![CDATA[<p>Zabbix 监控进程宕机</p>
<p>  业务需求后端进程宕机以后能在短时间内迅速拉起，业务影响不大，但是开发需要查看coredump，要求能监控到pid变化；在现有构架下zabbix能监控并报警；</p>
<p>当然zabbix设置报警设置就不再一一</p>
<p>在每台服务器/etc/zabbix/zabbix_agentd.conf设置路径：此例只需要piddiff.sh</p>
<p>UserParameter=checkpid,sh /usr/local/script/piddiff.sh</p>
<p>UserParameter=test,sh /usr/local/script/test.sh</p>
<p>UserParameter=discovery.process,/usr/local/script/disprocess.sh</p>
<p>UserParameter=process.check[*],/usr/local/script/proc_check.sh $1 $2 $3</p>
<p>/usr/local/script下面存放脚本</p>
<p>Vim piddiff.sh</p>
<p>aapid为业务监控id 取值根据业务需求；</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#/bin/sh</span></span><br><span class="line"></span><br><span class="line">onl_ok=1</span><br><span class="line"></span><br><span class="line">onl_cored=3</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span>=/usr/local/script</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -f <span class="string">"<span class="variable">$dir</span>/old.txt"</span> ]];<span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"> ps aux|grep aapid |grep -v grep|grep -v /bin/bash|awk  <span class="string">'{print $2,$11}'</span> &gt; <span class="variable">$dir</span>/old.txt</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    </span><br><span class="line">         <span class="built_in">sleep</span> 1s           </span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"> ps aux|grep aapid |grep -v grep|grep -v /bin/bash|awk  <span class="string">'{print $2,$11}'</span> &gt; <span class="variable">$dir</span>/now.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! diff -q <span class="variable">$dir</span>/old.txt  <span class="variable">$dir</span>/now.txt &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">          <span class="built_in">echo</span> <span class="variable">$onl_cored</span></span><br><span class="line">    </span><br><span class="line">          diff -c <span class="variable">$dir</span>/old.txt  <span class="variable">$dir</span>/now.txt &gt; <span class="variable">$dir</span>/`<span class="built_in">date</span> <span class="string">"+%Y%m%d%H%M"</span>`_diff.txt</span><br><span class="line">    </span><br><span class="line">          <span class="built_in">cat</span> <span class="variable">$dir</span>/now.txt &gt;<span class="variable">$dir</span>/old.txt</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">    </span><br><span class="line">          <span class="built_in">echo</span> <span class="variable">$onl_ok</span>    </span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>

<p>一个简单的判断脚本；</p>
<p>Zabbix30秒会抓取一次，正常没变化为1，有变化为3，那么zabbix抓取数值为3则表示pid有变化，会发出警报；</p>
<p>Zabbix设置：</p>
<p>监控项模板添加如下：</p>
<p><img src="/../imgages/20231113-1.png"></p>
<p>触发器：{Template OS Linux:checkpid.last()}=3</p>
<p><img src="/../images/20231113-2.jpg"></p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>apache多网站对应80端口</title>
    <url>/2023/11/13/apache%E5%A4%9A%E7%BD%91%E7%AB%99%E5%AF%B9%E5%BA%9480%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>一台服务器绑定多个域名，已经装了apache，nginx就不使用了，利用apache主机头名虚拟主机用80端口对应多个网站，万能的网络上面有文档如下：</p>
<p>Aapche 如果需要绑定多个域名到一个IP上,是支持的。需要注意以下2点:</p>
<p>1 必须要开启 NameVirtualHost开关选项，</p>
<p>如：NameVirtualHost 220.231.220.231:80</p>
<p>2 NameVirtualHost 需要指定具体的端口</p>
<p>例如”:80″,跟&lt;VirtualHost 220.231.32.*:80&gt;对应，否则会报错:</p>
<p>mixing * ports and non-* ports with a NameVirtualHost address is not supported, proceeding with undefined results。</p>
<p>翻译过来就是: NameVirtualHost 地址，指定端口和不指定端口混合使用是不支持的，将会产生未逾期的后果。</p>
<p>未逾期的后果就是: 第2个不起作用，仅当一个站点设置起作用。</p>
<p>按着做下来：</p>
<p>IncludeOptional conf.d/*.conf</p>
<p>ServerSignature Off</p>
<p>NameVirtualHost 220.231.220.231:80</p>
<p>&lt;VirtualHost 220.231.220.231:80&gt;&nbsp;&nbsp;</p>
<p>ServerAdmin&nbsp; &nbsp;<a href="mailto:postmaster@aaa.net">postmaster@aaa.net</a>&nbsp;</p>
<p>directoryIndex&nbsp; index.html index.php index.htm&nbsp;&nbsp;</p>
<p>ServerName <a href="http://www.aaa.net/">www.aaa.net</a></p>
<p>DocumentRoot&nbsp; /data/www/wress/</p>
<p>&lt;Directory “/data/www/wress/“&gt;&nbsp;&nbsp;</p>
<p>&nbsp; &nbsp;Options -Indexes&nbsp;&nbsp;</p>
<p>&nbsp; &nbsp;Options FollowSymLinks Indexes</p>
<p>&nbsp; &nbsp; AllowOverride All&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; Require all granted&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;</p>
<p>ErrorLog logs/<a href="http://www.aaa.net-error_log/">www.aaa.net-error_log</a></p>
<p>&nbsp;CustomLog logs/<a href="http://www.aaa.net-access_log/">www.aaa.net-access_log</a> common</p>
<p>&nbsp;</p>
<p>&lt;VirtualHost 220.231.220.231:80&gt;</p>
<p>ServerAdmin&nbsp; <a href="mailto:postmaster@aaa.net">postmaster@aaa.net</a></p>
<p>directoryIndex&nbsp; index.html index.php index.htm&nbsp;&nbsp;</p>
<p>ServerName img.aaa.net</p>
<p>#ServerName 220.231.220.231</p>
<p>DocumentRoot&nbsp; /data/www/html/</p>
<p>&lt;Directory “/data/www/html/“&gt;</p>
<p>&nbsp; &nbsp; Options -Indexes&nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; Options FollowSymLinks Indexes</p>
<p>&nbsp; &nbsp; AllowOverride All</p>
<p>&nbsp; &nbsp;Require all granted</p>


<p>ErrorLog logs/img.aaa.net-error_log</p>
<p>CustomLog logs/img.aaa.net-access_log common</p>


<h2 id="这样都可以访问，apache也可以实现，做个小笔记。"><a href="#这样都可以访问，apache也可以实现，做个小笔记。" class="headerlink" title="这样都可以访问，apache也可以实现，做个小笔记。"></a>这样都可以访问，apache也可以实现，做个小笔记。</h2>]]></content>
  </entry>
  <entry>
    <title>frp搭建</title>
    <url>/2023/11/10/frp%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p> &nbsp; 开发不在公司需要连到公司内网调试业务，有点周折，frp内网穿透来帮忙。网上很多文章，自己做个小笔记。</p>
<p>首先到官网：</p>
<p>&nbsp;<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p>
<p>下载: frp_0.16.0_linux_amd64.tar.gz服务器端</p>
<p>解压出来ls:</p>
<p>frpc&nbsp; frpc_full.ini&nbsp; frpc_http.ini&nbsp; frpc.ini&nbsp; frps&nbsp; frps_full.ini&nbsp; frps.ini&nbsp; LICENSE&nbsp; nohup.out</p>
<p>服务器端只需要两个文件frps和frps.ini,其中frps为可执行文件，frps.ini为配置文件默认配置文件如下：其中bind_addr为本机IP,bind_port为frp对客户端的端口号，auto_token是客户端连接服务器端的口令。</p>
<p>[common]</p>
<p>Bind_addr=0.0.0.0</p>
<p>Bind_port =4443</p>
<p>Auto_token = frp</p>
<p>配置好以后可以运行起来./frps -c ./frps.ini</p>
<p>最好后台运行：nohup ./frps -c ./frps.ini &amp;</p>
<p>2018/05/17 10:49:11 [I] [service.go:96] frps tcp listen on 0.0.0.0:4443</p>
<p>2018/05/17 10:49:11 [I] [main.go:112] Start frps success</p>
<p>&nbsp;需要穿透端口的服务器端开启：</p>
<p>nohup ./frps -c ./frps.ini &amp;</p>
<p>同样将客户端解压后有七个文件，只需要frpc和frpc.ini,配置文件如下：</p>
<p>&nbsp;[common]</p>
<p>Server_addr = 123.123.123.123</p>
<p>Server_port = 4443</p>
<p>Auto-token = frp</p>
<p>[ssh_1]</p>
<p>Type = tcp</p>
<p>Local_ip = 127.0.0.1</p>
<p>Local_port = 22</p>
<p>Remote_port = 10085</p>
<p>注意：server_addr是服务器端的公网IP地址，server_port是frp服务端口号，auto_token是连接服务器的口令，必须和服务器保持一致。[ssh_1]是客户端通过服务器与用户之间的通道名，每个客户端必须不一样，remote_port是服务器端对外提供本机服务的端口号，即用户连接123.123.123.123:10085，相当于连接127.0.0.1:22,即arm板上的ssh服务</p>
<p>运行客户端：./frpc -c ./frpc.ini</p>
<p>&nbsp;</p>
<p>当前的配置</p>
<p>more frpc.ini</p>
<p>[common]</p>
<p>server_addr = dem.abc.com</p>
<p>server_port = 7000</p>
<p>[game]</p>
<p>type = tcp</p>
<p>local_ip = 192.168.1.232</p>
<p>local_port = 9001</p>
<p>remote_port = 6000</p>
<p>&nbsp;</p>
<p>[http]</p>
<p>type = tcp</p>
<p>local_ip = 192.168.1.232</p>
<p>local_port = 80</p>
<p>remote_port = 6001</p>
<p>&nbsp;</p>
<p>[mysql]</p>
<p>type = tcp</p>
<p>local_ip = 192.168.1.235</p>
<p>local_port = 3306</p>
<p>remote_port = 13306</p>
<p>more frpc_http.ini</p>
<p>[common]</p>
<p>server_addr = dem.abc.com</p>
<p>server_port = 7000</p>
<p>&nbsp;</p>
<p>[http]</p>
<p>type = tcp</p>
<p>local_ip = 192.168.1.232</p>
<p>local_port = 80</p>
<p>remote_port = 6001</p>
<p>这样demo.abc.com 的13306映射到3306,6001映射到80端口等等；</p>
<p>在客户端开启：最好后台运行启动客户端proxy：</p>
<p>nohup ./frpc&nbsp; -c ./frpc.ini &amp;</p>
<p>[I] [control.go:240] [e465e02f8bad1e5b] login to server success, get run id [e465e02f8bad1e5b], server udp port [0]</p>
<p>2018/05/17 10:48:16 [I] [control.go:165] [e465e02f8bad1e5b] [http] start proxy success</p>
<p>2018/05/17 10:48:16 [I] [control.go:165] [e465e02f8bad1e5b] [mysql] start proxy success</p>
<p>2018/05/17 10:49:11 [I] [service.go:96] frps tcp listen on 0.0.0.0:7000</p>
<p>2018/05/17 10:49:11 [I] [main.go:112] Start frps success</p>
<p>2018/05/17 10:49:11 [I] [main.go:114] PrivilegeMode is enabled, you should pay more attention to security issues</p>
<p>&nbsp;</p>
<p>PS：配置很简单，但是记得nohup ./frps -c ./frps.ini &amp; 在要穿透的远程服务器开启，nohup ./frpc&nbsp; -c ./frpc.ini &amp; 在内网开启，记得开放远程服务器穿透端口；</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>coredump 路径格式</title>
    <url>/2023/11/13/coredump-%E8%B7%AF%E5%BE%84%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>Coredump</p>
<p>业务进程宕机以后开发需要查看dump查找定位问题，所有服务器初始化环境时候统一定制coredump路径；</p>
<p>1.Core文件简介</p>
<p>Core文件其实就是内存的映像，当程序崩溃时，存储内存的相应信息，主用用于对程序进行调试。当程序崩溃时便会产生core文件，其实准确的应该说是core dump 文件,默认生成位置与可执行程序位于同一目录下，文件名为core,其中是某一数字。</p>
<p>2.开启或关闭Core文件的生成</p>
<p>关闭或阻止core文件生成：</p>
<p>$ulimit -c 0</p>
<p>打开core文件生成：</p>
<p>$ulimit -c unlimited</p>
<p>检查core文件的选项是否打开：</p>
<p>$ulimit -a</p>
<p>ulimit参数含义如下：&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a&nbsp;&nbsp;&nbsp;&nbsp; All current limits are reported<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c&nbsp;&nbsp;&nbsp;&nbsp; The maximum size of core files created<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -d&nbsp;&nbsp;&nbsp;&nbsp; The maximum size of a process data segment<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -e&nbsp;&nbsp;&nbsp;&nbsp; The maximum scheduling priority (“nice”)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -f&nbsp;&nbsp;&nbsp;&nbsp; The maximum size of files written by the shell and its children<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -i&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of pending signals<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -l&nbsp;&nbsp;&nbsp;&nbsp; The maximum size that may be locked into memory<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -m&nbsp;&nbsp;&nbsp;&nbsp; The maximum resident set size (has no effect on Linux)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of open file descriptors (most systems do not allow this value to be set)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -p&nbsp;&nbsp;&nbsp;&nbsp; The pipe size in 512-byte blocks (this may not be set)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -q&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of bytes in POSIX message queues<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -r&nbsp;&nbsp;&nbsp;&nbsp; The maximum real-time scheduling priority<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s&nbsp;&nbsp;&nbsp;&nbsp; The maximum stack size<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -t&nbsp;&nbsp;&nbsp;&nbsp; The maximum amount of cpu time in seconds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -u&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of processes available to a single user<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -v&nbsp;&nbsp;&nbsp;&nbsp; The maximum amount of virtual memory available to the shell<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -x&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of file locks</p>
<p>&nbsp;</p>
<p>#ulimit -a</p>
<p>core file size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (blocks, -c) unlimited</p>
<p>data seg size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (kbytes, -d) unlimited</p>
<p>scheduling priority&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-e) 0</p>
<p>file size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (blocks, -f) unlimited</p>
<p>pending signals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-i) 127974</p>
<p>max locked memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (kbytes, -l) 64</p>
<p>max memory size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (kbytes, -m) unlimited</p>
<p>open files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-n) 100000</p>
<p>pipe size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (512 bytes, -p) 8</p>
<p>POSIX message queues&nbsp;&nbsp;&nbsp;&nbsp; (bytes, -q) 819200</p>
<p>real-time priority&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-r) 0</p>
<p>stack size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (kbytes, -s) 8192</p>
<p>cpu time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seconds, -t) unlimited</p>
<p>max user processes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-u) 655360</p>
<p>virtual memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (kbytes, -v) unlimited</p>
<p>file locks&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-x) unlimited而我们需要修改的是open files (-n) 1024的值</p>
<p>于是命令就是limit -n 2048(随各自需要设置)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>以上配置只对当前会话起作用，下次重新登陆后，还是得重新配置。要想配置永久生效，得在/etc/profile或者/etc/security/limits.conf文件中进行配置。</p>
<p>首先以root权限登陆，然后打开/etc/security/limits.conf文件，进行配置：</p>
<p>#vim /etc/security/limits.conf</p>
<p><domain> &nbsp; &nbsp;<type> &nbsp; &nbsp;<item> &nbsp; &nbsp; &nbsp; &nbsp;<value></value></item></type></domain></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;soft &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;core &nbsp; &nbsp; &nbsp; &nbsp; unlimited</p>
<p>或者在/etc/profile中作如下配置：</p>
<p>#vim /etc/profile</p>
<p>ulimit -S -c unlimited &gt;/dev/null 2&gt;&amp;1</p>
<p>或者想配置只针对某一用户有效，则修改此用户的<del>/.bashrc或者</del>/.bash_profile文件：</p>
<p>limit -c unlimited</p>
<p>ulimit -c 0 是禁止产生core文件，而ulimit -c 1024则限制产生的core文件的大小不能超过1024kb</p>
<p>3.设置Core Dump的核心转储文件目录和命名规则</p>
<p>/proc/sys/kernel/core_uses_pid可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0<br>/proc/sys/kernel/core_pattern可以设置格式化的core文件保存位置或文件名，比如原来文件内容是core-%e<br>可以这样修改:<br>echo “/data/common/coredump/core-%e-%p-%t” &gt;/proc/sys/kernel/core_pattern<br>将会控制所产生的core文件会存放到/data/common/coredump目录下，产生的文件名为core-进程名-pid-时间戳<br>以下是参数列表:<br>&nbsp;&nbsp;&nbsp; %p - insert pid into filename 添加pid<br>&nbsp;&nbsp;&nbsp; %u - insert current uid into filename 添加当前uid<br>&nbsp;&nbsp;&nbsp; %g - insert current gid into filename 添加当前gid<br>&nbsp;&nbsp;&nbsp; %s - insert signal that caused the coredump into the filename 添加导致产生core的信号<br>&nbsp;&nbsp;&nbsp; %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间<br>&nbsp;&nbsp;&nbsp; %h - insert hostname where the coredump happened into filename 添加主机名<br>&nbsp;&nbsp;&nbsp; %e - insert coredumping executable name into filename 添加命令名</p>
<p>4.core文件的使用</p>
<p>在core文件所在目录下键入:<br>gdb -c core &nbsp; （-c指定core文件）<br>它会启动GNU的调试器，来调试core文件，并且会显示生成此core文件的程序名，中止此程序的信号等等<br>如果你已经知道是由什么程序生成此core文件的，比如MyServer崩溃了生成core.12345，那么用此指令调试:<br>gdb -c core MyServer</p>
<p>&nbsp;源：<a href="https://www.cnblogs.com/xiaodoujiaohome/p/6222895.html">https://www.cnblogs.com/xiaodoujiaohome/p/6222895.html</a>&nbsp;</p>
<p>5.永久生效：<br>当前不重启生效：<br>你可以用下列方式来完成<br>sysctl -w kernel.core_pattern=/data/common/coredump/core-%e-%p-%t&nbsp;</p>
<p>或</p>
<p>echo “/data/common/coredump/core-%e-%p-%t” &gt;/proc/sys/kernel/core_pattern</p>
<p>这些操作一旦计算机重启，则会丢失，如果你想持久化这些操作，可以在 /etc/sysctl.conf文件中增加：<br>kernel.core_pattern=/data/common/coredump/core-%e-%p-%t&nbsp;</p>
<p>加好后，如果你想不重启看看效果的话，则用下面的命令：<br>sysctl -p /etc/sysctl.conf</p>
<h1 id="sysctl-p-etc-sysctl-conf"><a href="#sysctl-p-etc-sysctl-conf" class="headerlink" title="sysctl -p /etc/sysctl.conf"></a>sysctl -p /etc/sysctl.conf</h1><p>net.ipv4.ip_forward = 0</p>
<p>net.ipv4.conf.default.rp_filter = 1</p>
<p>net.ipv4.conf.default.accept_source_route = 0</p>
<p>kernel.core_uses_pid = 1</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>kernel.msgmnb = 65536</p>
<p>kernel.msgmax = 65536</p>
<p>net.ipv6.conf.lo.disable_ipv6 = 1</p>
<p>net.ipv4.conf.all.promote_secondaries = 1</p>
<p>net.ipv4.conf.default.promote_secondaries = 1</p>
<p>net.ipv6.neigh.default.gc_thresh3 = 4096</p>
<p>net.ipv4.neigh.default.gc_thresh3 = 4096</p>
<p>kernel.softlockup_panic = 1</p>
<p>kernel.sysrq = 1</p>
<p>net.ipv6.conf.all.disable_ipv6 = 1</p>
<p>net.ipv6.conf.default.disable_ipv6 = 1</p>
<p>vm.overcommit_memory = 1</p>
<p>kernel.numa_balancing = 0</p>
<p>kernel.shmmax = 68719476736</p>
<p>kernel.printk = 5</p>
<p>kernel.core_pattern = /data/common/coredump/core-%e-%p-%t</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>kafka Create topic 报错</title>
    <url>/2023/11/13/kafka-Create-topic-%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic kk_log<br>报错如下：<br>WARN [Consumer clientId=consumer-1, groupId=console-consumer-507] Connection to node -1 could not be established. Broker may not be available. (org.apache.kafka.clients.NetworkClient)</p>
<p>配置server.confg时候设置的<br>advertised.listeners=PLAINTEXT://10.171.222.26:9092<br>此时需要用配置的IP而非localhost地址：</p>
<p>nohup bin/zookeeper-server-start.sh config/zookeeper.properties &gt; /dev/null 2&gt;&amp;1 &amp;<br>nohup bin/kafka-server-start.sh config/server.properties &gt; /dev/null 2&gt;&amp;1 &amp;<br>netstat -ntpl|egrep “(2181|9092)”<br>运行起来再试试<br>bin/kafka-console-consumer.sh –bootstrap-server 10.171.222.26:9092 –topic kk_log<br>应该就可以了。<br>做个小笔记。</p>
<p>PS zookeeper 报错，宕掉；</p>
<p>[2016-06-27 12:07:14,065] INFO Closed socket connection for client /127.0.0.1:58824 (no session established for client) (org.apache.zookeeper.server.NIOServerCnxn) [2016-<br>[2016-06-27 12:07:17,351] INFO Refusing session request for client /127.0.0.1:58834 as it has seen zxid 0xd820 our last zxid is 0x20 client must try another server (org.apache.zookeeper.server.ZooKeeperServer)<br>[2016-06-27 12:07:17,351] INFO Closed socket connection for client /127.0.0.1:58834 (no session established for client) (org.apache.zookeeper.server.NIOServerCnxn)<br>[2016-06-27 12:07:19,048] INFO Accepted socket connection from /127.0.0.1:58840 (org.apache.zookeeper.server.NIOServerCnxnFactory)<br>[2016-06-27 12:07:19,048] INFO Refusing session request for client /127.0.0.1:58840 as it has seen zxid 0xd820 our last zxid is 0x20 client must try another server (org.apache.zookeeper.server.ZooKeeperServer)</p>
<p>解决方法</p>
<p>报错原因：服务器上还有应用在不停的向zookeeper发送请求</p>
<p>解决方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用top -u [username]查看该用户下的所有进程，发现多了一个java进程在运行着；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、kill掉与java相关的进程；</p>
<p>2、关闭zookeeper，删除zoo.cfg中的dataDir配置的文件夹；</p>
<h2 id="3、重启zookeeper。"><a href="#3、重启zookeeper。" class="headerlink" title="3、重启zookeeper。"></a>3、重启zookeeper。</h2>]]></content>
  </entry>
  <entry>
    <title>hexogit搭建个人网站</title>
    <url>/2023/11/14/hexogit%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="1-nodejs安装"><a href="#1-nodejs安装" class="headerlink" title="1.nodejs安装"></a>1.nodejs安装</h1><h2 id="1-1使用Node-Version-Manager（nvm工具）"><a href="#1-1使用Node-Version-Manager（nvm工具）" class="headerlink" title="1.1使用Node Version Manager（nvm工具）"></a>1.1使用Node Version Manager（nvm工具）</h2><p> install stable`是使用Node Version Manager（nvm）安装Node.js的命令。nvm是一个用于管理多个Node.js版本的工具，可以轻松地在同一台机器上安装、切换和管理不同版本的Node.js。</p>
<p><code>nvm install stable</code>指令表示安装最新的稳定版本的Node.js。执行此命令后，nvm会从Node.js官方仓库下载并自动安装最新的稳定版Node.js。安装过程可能需要一些时间，具体取决于您的网络速度。</p>
<p>在centOS上安装Node.js，您可以按照以下步骤进行操作：</p>
<ol>
<li>使用以下命令更新系统软件包：</li>
</ol>
<p>sudo yum update</p>
<ol start="2">
<li>安装Node.js依赖项。使用以下命令执行：</li>
</ol>
<p>sudo yum install -y gcc-c++ make</p>
<p>相关库</p>
<ol>
<li>更新系统：</li>
</ol>
<p>sudo yum update2. 安装EPEL存储库（Extra Packages for Enterprise Linux，附加软件包）：</p>
<p>sudo yum install epel-release3. 安装devtoolset-7工具集：</p>
<p>sudo yum install centos-release-scl</p>
<p>sudo yum install devtoolset-74. 启用devtoolset-7工具集：</p>
<p>scl enable devtoolset-7 bash</p>
<p>sudo yum install centos-release-scl</p>
<p>sudo yum install devtoolset-7-gcc devtoolset-7-gcc-c++ devtoolset-7-libstdc++-devel</p>
<ol start="3">
<li>在CentOS上，您可以使用Node Version Manager（NVM）来安装和管理多个Node.js版本。首先，在CentOS上安装NVM。使用以下命令从NVM的GitHub仓库获取安装脚本：</li>
</ol>
<p>curl -o- <a href="https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh">https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh</a> | bash国内：</p>
<p>curl -o- <a href="https://gitee.com/mirrors/nvm/raw/v0.39.0/install.sh">https://gitee.com/mirrors/nvm/raw/v0.39.0/install.sh</a> | bash</p>
<p>注意：这是安装最新版本的NVM。您可以在NVM的GitHub页面（<a href="https://github.com/nvm-sh/nvm%EF%BC%89%E4%B8%8A%E6%9F%A5%E7%9C%8B%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%B9%B6%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%BA%94%E7%9A%84URL%E3%80%82">https://github.com/nvm-sh/nvm）上查看最新版本并使用相应的URL。</a></p>
<ol start="4">
<li>安装完成后，关闭并重新打开终端，或者使用以下命令重新加载终端以使NVM生效：</li>
</ol>
<p>source ~/.bashrc</p>
<ol start="5">
<li>使用NVM安装想要的Node.js版本。例如，运行以下命令安装最新的稳定版本：</li>
</ol>
<p>nvm install stable</p>
<p>或者，您可以指定其他Node.js版本，例如：</p>
<p>nvm install 14.17.6</p>
<p>nvm install 16.20.2</p>
<p>这将下载并安装指定版本的Node.js。</p>
<ol start="6">
<li>检查Node.js的安装是否成功。运行以下命令检查Node.js版本：</li>
</ol>
<p>[root@localhost /data/myblog]$npm -v<br>8.19.4<br>[root@localhost /data/myblog]$node -v<br>v16.20.2</p>
<p>[root@mytest2 tools]# node -v</p>
<p>node: /lib64/libm.so.6: version `GLIBC_2.27’ not found (required by node)</p>
<p>node: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.20’ not found (required by node)</p>
<p>node: /lib64/libstdc++.so.6: version `CXXABI_1.3.9’ not found (required by node)</p>
<p>node: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21’ not found (required by node)</p>
<p>node: /lib64/libc.so.6: version `GLIBC_2.27’ not found (required by node)</p>
<p>node: /lib64/libc.so.6: version `GLIBC_2.28’ not found (required by node)</p>
<p>node: /lib64/libc.so.6: version `GLIBC_2.25’ not found (required by node)</p>
<p>[root@mytest2 tools]# npm -v</p>
<p>node: /lib64/libm.so.6: version `GLIBC_2.27’ not found (required by node)</p>
<p>node: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.20’ not found (required by node)</p>
<p>node: /lib64/libstdc++.so.6: version `CXXABI_1.3.9’ not found (required by node)</p>
<p>node: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21’ not found (required by node)</p>
<p>node: /lib64/libc.so.6: version `GLIBC_2.27’ not found (required by node)</p>
<p>node: /lib64/libc.so.6: version `GLIBC_2.28’ not found (required by node)</p>
<p>node: /lib64/libc.so.6: version `GLIBC_2.25’ not found (required by node)</p>
<p>[root@mytest2 tools]# ldd –version</p>
<p>ldd (GNU libc) 2.17</p>
<p>版本太高换回nvm install 16.20.2</p>
<h1 id="2-git-repo仓库安装"><a href="#2-git-repo仓库安装" class="headerlink" title="2.git repo仓库安装"></a>2.git repo仓库安装</h1><p>github也可以注册账号，Github Pages可以直接生成页面，不过国外的网速实在是龟速，gitee也有这个功能，实名认证太麻烦，索性在自己测试机上直接建立git仓库，直接推送建立站点而已，后续国内服务器需要网站备案。</p>
<p>1.安装git  ubuntu/debian sudo apt-get install git</p>
<p>​               centos   sudo yum install git</p>
<p>2.创建一个git用户，用来运行git服务：</p>
<p>$ sudo adduser git<br>3.创建证书登录实现git免密推送：</p>
<p>收集所有需要登录的用户的公钥id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p>
<p>4.初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定git是/data/blog/blog.git，工作目录：/data/myblog 在/data/blog目录下输入命令：</p>
<p>$ sudo git init –bare blog.git<br>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p>
<p>$ sudo chown -R git:git blog.git</p>
<p>cd blog.git/hooks</p>
<p>vim post-receive</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git --work-tree=/data/myblog --git-dir=/data/blog/blog.git checkout -f</span><br></pre></td></tr></tbody></table></figure>

<p>chmod +x post-receive</p>
<p>5.禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p>
<p>gitx:1001:1001:,,,:/home/git:/bin/bash<br>改为：</p>
<p>gitx:1001:1001:,,,:/home/git:/usr/bin/git-shell<br>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p>
<p>git clone ssh://git@ip:port/data/blog/blog.git<br>Cloning into ‘blog’…</p>
<p>几个问题：</p>
<p>a.git目录路径要看清楚，不在当前目录会报:does not appear to be a git repository<br>fatal: Could not read from remote repository.类似的错误 ；</p>
<p>git@ip:port/data/blog/blog.git</p>
<p>b. git ssh 连接 ： ssh://git@ip:port/data/blog/blog.git</p>
<h1 id="3-hexo安装及推送"><a href="#3-hexo安装及推送" class="headerlink" title="3.hexo安装及推送"></a>3.hexo安装及推送</h1><h2 id="3-1-hexo安装"><a href="#3-1-hexo安装" class="headerlink" title="3.1 hexo安装"></a>3.1 hexo安装</h2><p>npm install hexo-cli -g<br> hexo init blog<br> cd blog<br>npm install<br> hexo g # 或者hexo generate<br> hexo s # 或者hexo server，可以在<a href="http://localhost:4000/">http://localhost:4000/</a> 查看</p>
<p>也可以hexo server -p 80 -l</p>
<p>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</p>
<p>hexo server (hexo s) 启动本地web服务，用于博客的预览</p>
<p>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）</p>
<p>hexo new “postName” #新建文章<br> hexo new page “pageName” #新建页面</p>
<p>简写：</p>
<p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy</p>
<p>hexo d -g #生成部署<br>hexo s -g #生成预览</p>
<p>经常用到：</p>
<p>hexo clean</p>
<p>hexo g</p>
<p>hexo d</p>
<h2 id="3-2使用hexo-deploy部署"><a href="#3-2使用hexo-deploy部署" class="headerlink" title="3.2使用hexo deploy部署"></a>3.2使用hexo deploy部署</h2><p>安装一个扩展：</p>
<p>$ npm install hexo-deployer-git –save</p>
<p>hexo deploy可以部署到很多平台，具体可以参考这个链接. 如果部署到github，需要在根目录/data/blog/配置文件_config.xml中作如下修改：</p>
<p>deploy:<br>  type: git<br>repo: ssh://git@ip:port/data/blog/blog.git<br>  branch: master<br>然后在命令行中执行</p>
<p>hexo d<br>即可完成部署。</p>
<p>hexo主题很多选择一个喜欢的去修改吧</p>
<p>比如：</p>
<p>git clone <a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a> themes/next</p>
<p>下载到themes 的next 主题，或者matery大佬的主题，下载以后自己修改成自己喜欢的样式即可。</p>
<h1 id="4-web站点搭建"><a href="#4-web站点搭建" class="headerlink" title="4.web站点搭建"></a>4.web站点搭建</h1><p>首先有一台自己的服务器，比如centos或者ubuntu，debian，安装nginx或者tengine，对于个人静态站点基本上nginx可以满足，tengine需要手动安装，喜欢的可以尝试一下。</p>
<p>简单的yum install nginx</p>
<p>cd /etc/nginx/</p>
<p>vim nginx.conf</p>
<p>server_tokens off; 隐藏版本号；</p>
<p>也可以做好多优化；这里只说实现web功能</p>
<p>nginx一般在/etc/nginx/conf.d/ 配置站点conf文件，tengine在/etc/nginx/sites-enabled/配置，看个人喜好。</p>
<p>vim mybog.conf 基本配置如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.icmpy.net;</span><br><span class="line">    return 301 blog.icmpy.net$request_uri;</span><br><span class="line">}</span><br><span class="line">server {</span><br><span class="line">   #ssl on;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name blog.icmpy.net;</span><br><span class="line">    root /data/myblog; # 根目录为web</span><br><span class="line">    index index.php index index.html index.htm;</span><br><span class="line">    ssl_certificate /etc/nginx/ssl/blog.icmpy.net.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/blog.icmpy.net.key;</span><br><span class="line">   ssl_session_timeout  5m;</span><br><span class="line">    ssl_certificate /etc/nginx/ssl/blog.icmpy.net.pem;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/blog.icmpy.net.key;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">    # Log files for Debug</span><br><span class="line">    error_log  /var/log/nginx/blog_error.log;</span><br><span class="line">    access_log /var/log/nginx/blog_access.log;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于做了ssl证书，80做了个跳转到443上面，域名需要到平台做解析，A记录到自己的服务器，如果流量大的话可以做cdn，Cname到平台给的记录值，ssl证书申请，主流云平台都可以免费申请，填写一些资料以后很快就可以签发证书，选择对应的证书上传即可。</p>
]]></content>
  </entry>
  <entry>
    <title>linux 磁盘挂载扩充格式化</title>
    <url>/2023/11/10/linux-%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E6%89%A9%E5%85%85%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<h1 id="linux服务器硬盘格式化挂载："><a href="#linux服务器硬盘格式化挂载：" class="headerlink" title="linux服务器硬盘格式化挂载："></a>linux服务器硬盘格式化挂载：</h1><p>请根据以下步骤对数据盘进行分区以及格式化，并挂载分区使数据盘可用。</p>
<h2 id="1-1-查看数据盘信息"><a href="#1-1-查看数据盘信息" class="headerlink" title="1.1 查看数据盘信息"></a>1.1 查看数据盘信息</h2><p>登录Linux云服务器后，可以使用“fdisk -l”命令查看数据盘相关信息。<br>使用“df -h”命令，无法看到未分区和格式化的数据盘。 </p>
<h2 id="1-2-数据盘分区"><a href="#1-2-数据盘分区" class="headerlink" title="1.2 数据盘分区"></a>1.2 数据盘分区</h2><p>执行以下命令，对数据盘进行分区。</p>
<p>fdisk /dev/xvdb</p>
<p>按照界面的提示，依次输入“n”(新建分区)、“p”(新建扩展分区)、“1”(使用第1个主分区)，两次回车(使用默认配置)，输入“wq”(保存分区表)，开始分区。<br>这里是以创建1个分区为例，开发者也可以根据自己的需求创建多个分区。</p>
<h2 id="1-3-查看新分区"><a href="#1-3-查看新分区" class="headerlink" title="1.3 查看新分区"></a>1.3 查看新分区</h2><p>使用“fdisk -l”命令，即可查看到，新的分区xvdb1已经创建完成。</p>
<h2 id="1-4-格式化新分区"><a href="#1-4-格式化新分区" class="headerlink" title="1.4 格式化新分区"></a>1.4 格式化新分区</h2><p>在进行分区格式化时，开发者可以自行决定文件系统的格式，如ext2、ext3等。<br>这里以“ext3”为例：<br>使用下面的命令对新分区进行格式化。 </p>
<p>mkfs.ext3 /dev/xvdb1</p>
<h2 id="1-5-挂载新分区"><a href="#1-5-挂载新分区" class="headerlink" title="1.5 挂载新分区"></a>1.5 挂载新分区</h2><p>使用命令“mkdir /mydata”创建mydata目录，再通过“mount /dev/xvdb1 /mydata”命令手动挂载新分区后，用“df -h”命令查看，出现以下信息说明挂载成功，即可以查看到数据盘了。</p>
<h2 id="1-6-添加分区信息"><a href="#1-6-添加分区信息" class="headerlink" title="1.6 添加分区信息"></a>1.6 添加分区信息</h2><p>如果希望云服务器在重启或开机时能自动挂载数据盘，必须将分区信息添加到/etc/fstab中。如果没有添加，则云服务器重启或开机后，都不能自动挂载数据盘。<br>使用“echo ‘/dev/xvdb1 /mydata ext3 defaults 0 0’ &gt;&gt; /etc/fstab”命令添加分区信息后，使用“cat /etc/fstab”命令查看，出现以下信息表示添加分区信息成功。</p>
<h1 id="2-腾讯云服务器硬盘扩充，新空间增加到已有分区空间中："><a href="#2-腾讯云服务器硬盘扩充，新空间增加到已有分区空间中：" class="headerlink" title="2.腾讯云服务器硬盘扩充，新空间增加到已有分区空间中："></a>2.腾讯云服务器硬盘扩充，新空间增加到已有分区空间中：</h1><p>  线上业务服务器1T硬盘，日志量太大，需要扩充到2T硬盘，关机购买硬盘以后启动开始在原有盘上面开始扩充：</p>
<h2 id="2-1-查看数据盘信息"><a href="#2-1-查看数据盘信息" class="headerlink" title="2.1 查看数据盘信息"></a>2.1 查看数据盘信息</h2><h2 id="root-VM-0-17-centos-fdisk-l"><a href="#root-VM-0-17-centos-fdisk-l" class="headerlink" title="[root@VM_0_17_centos ~]# fdisk -l"></a>[root@VM_0_17_centos ~]# fdisk -l</h2><p> Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors</p>
<p>Units = sectors of 1 * 512 = 512 bytes</p>
<p>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
<p>Disk label type: dos</p>
<p>Disk identifier: 0x000c7a75</p>
<p>   Device Boot      Start         End      Blocks   Id  System</p>
<p>/dev/vda1   *        2048   104857599    52427776   83  Linux</p>
<p>Disk /dev/vdb: 2147.5 GB, 2147483648000 bytes, 4194304000 sectors</p>
<p>Units = sectors of 1 * 512 = 512 bytes</p>
<p>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
<p>Disk label type: dos</p>
<p>Disk identifier: 0x947d4eff</p>
<p>   Device Boot      Start         End      Blocks   Id  System</p>
<p>/dev/vdb1            2048  2097151999  1048574976   83  Linux</p>
<h2 id="2-2查看原来1T磁盘："><a href="#2-2查看原来1T磁盘：" class="headerlink" title="2.2查看原来1T磁盘："></a>2.2查看原来1T磁盘：</h2><p>df -h</p>
<p>Filesystem      Size  Used Avail Use% Mounted on</p>
<p>/dev/vda1        50G  4.1G   43G   9% /</p>
<p>devtmpfs         16G     0   16G   0% /dev</p>
<p>tmpfs            16G   24K   16G   1% /dev/shm</p>
<p>tmpfs            16G  300K   16G   1% /run</p>
<p>tmpfs            16G     0   16G   0% /sys/fs/cgroup</p>
<p>/dev/vdb1       985G  150G  785G  17% /data</p>
<p>tmpfs           3.2G     0  3.2G   0% /run/user/0</p>
<h2 id="2-3卸载原硬盘："><a href="#2-3卸载原硬盘：" class="headerlink" title="2.3卸载原硬盘："></a>2.3卸载原硬盘：</h2><p>umount /data/</p>
<p>[root@VM_0_17_centos ~]# df -h</p>
<p>Filesystem      Size  Used Avail Use% Mounted on</p>
<p>/dev/vda1        50G  4.1G   43G   9% /</p>
<p>devtmpfs         16G     0   16G   0% /dev</p>
<p>tmpfs            16G   24K   16G   1% /dev/shm</p>
<p>tmpfs            16G  300K   16G   1% /run</p>
<p>tmpfs            16G     0   16G   0% /sys/fs/cgroup</p>
<p>tmpfs           3.2G     0  3.2G   0% /run/user/0</p>
<h2 id="2-4确认卸载："><a href="#2-4确认卸载：" class="headerlink" title="2.4确认卸载："></a>2.4确认卸载：</h2><p>[root@VM_0_17_centos ~]# fdisk -l</p>
<p>Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors</p>
<p>Units = sectors of 1 * 512 = 512 bytes</p>
<p>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
<p>Disk label type: dos</p>
<p>Disk identifier: 0x000c7a75</p>
<p>   Device Boot      Start         End      Blocks   Id  System</p>
<p>/dev/vda1   *        2048   104857599    52427776   83  Linux</p>
<p>Disk /dev/vdb: 2147.5 GB, 2147483648000 bytes, 4194304000 sectors</p>
<p>Units = sectors of 1 * 512 = 512 bytes</p>
<p>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
<p>Disk label type: dos</p>
<p>Disk identifier: 0x947d4eff</p>
<p>   Device Boot      Start         End      Blocks   Id  System</p>
<p>/dev/vdb1            2048  2097151999  1048574976   83  Linux</p>
<h2 id="2-5-开始格盘："><a href="#2-5-开始格盘：" class="headerlink" title="2.5 开始格盘："></a>2.5 开始格盘：</h2><p> 按照界面的提示，一次输入”p”(查看已有分区信息), ”d”(删除需要扩容的分区)、“n”(新建分区)、“p”(新建主分区)、“1”(使用第1个主分区，必须保持与需要扩容的分区一样)，两次回车(使用默认配置)，输入“w”(保存分区表)，开始分区。<br>这里是以创建1个分区为例，用户也可以根据自己的需求扩容多个分区。</p>
<p>[root@VM_0_17_centos ~]# fdisk  /dev/vdb</p>
<p>Welcome to fdisk (util-linux 2.23.2).</p>
<p>Changes will remain in memory only, until you decide to write them.</p>
<p>Be careful before using the write command.</p>
<p> Command (m for help): p</p>
<p>Disk /dev/vdb: 2147.5 GB, 2147483648000 bytes, 4194304000 sectors</p>
<p>Units = sectors of 1 * 512 = 512 bytes</p>
<p>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
<p>Disk label type: dos</p>
<p>Disk identifier: 0x947d4eff</p>
<p>   Device Boot      Start         End      Blocks   Id  System</p>
<p>/dev/vdb1            2048  2097151999  1048574976   83  Linux</p>
<p>Command (m for help): d</p>
<p>Selected partition 1</p>
<p>Partition 1 is deleted</p>
<p>Command (m for help): n</p>
<p>Partition type:</p>
<p>   p   primary (0 primary, 0 extended, 4 free)</p>
<p>   e   extended</p>
<p>Select (default p): p</p>
<p>Partition number (1-4, default 1): 1</p>
<p>First sector (2048-4194303999, default 2048):</p>
<p>Using default value 2048</p>
<p>Last sector, +sectors or +size{K,M,G} (2048-4194303999, default 4194303999):</p>
<p>Using default value 4194303999</p>
<p>Partition 1 of type Linux and of size 2 TiB is set</p>
<p>Command (m for help): w</p>
<p>The partition table has been altered!</p>
<p>Calling ioctl() to re-read partition table.</p>
<p>Syncing disks.</p>
<p>[root@VM_0_17_centos ~]# fdisk -l</p>
<p>Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors</p>
<p>Units = sectors of 1 * 512 = 512 bytes</p>
<p>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
<p>Disk label type: dos</p>
<p>Disk identifier: 0x000c7a75</p>
<p>   Device Boot      Start         End      Blocks   Id  System</p>
<p>/dev/vda1   *        2048   104857599    52427776   83  Linux</p>
<p>Disk /dev/vdb: 2147.5 GB, 2147483648000 bytes, 4194304000 sectors</p>
<p>Units = sectors of 1 * 512 = 512 bytes</p>
<p>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
<p>Disk label type: dos</p>
<p>Disk identifier: 0x947d4eff</p>
<pre><code>Device Boot      Start         End      Blocks   Id  System
</code></pre>
<p>/dev/vdb1            2048  4194303999  2097150976   83  Linux</p>
<h2 id="2-6确认磁盘"><a href="#2-6确认磁盘" class="headerlink" title="2.6确认磁盘"></a>2.6确认磁盘</h2><p>使用“fdisk –l /dev/vdb1”命令，即可查看到，新的分区vdb1已经创建并扩容完成：</p>
<p>[root@VM_0_17_centos ~]# fdisk -l /dev/vdb1</p>
<p> Disk /dev/vdb1: 2147.5 GB, 2147482599424 bytes, 4194301952 sectors</p>
<p>Units = sectors of 1 * 512 = 512 bytes</p>
<p>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>I/O size (minimum/optimal): 512 bytes / 512 bytes</p>
<h2 id="2-7-再使用e2fsck-f-dev-xvdc1检查扩容的分区是否ok"><a href="#2-7-再使用e2fsck-f-dev-xvdc1检查扩容的分区是否ok" class="headerlink" title="2.7 再使用e2fsck -f /dev/xvdc1检查扩容的分区是否ok"></a>2.7 再使用e2fsck -f /dev/xvdc1检查扩容的分区是否ok</h2><p>[root@VM_0_17_centos /]# e2fsck -f /dev/vd</p>
<p>vda   vda1  vdb   vdb1 </p>
<p>[root@VM_0_17_centos /]# e2fsck -f /dev/vdb1</p>
<p>e2fsck 1.42.9 (28-Dec-2013)</p>
<p>/dev/vdb1 is mounted.</p>
<p>e2fsck: Cannot continue, aborting.</p>
<p>似乎看到一个报错，不过后面查看扩充成功了，是不是成功了半信半疑的。。</p>
<h2 id="2-8-使用resize2fs-dev-xvdc1命令扩容分区："><a href="#2-8-使用resize2fs-dev-xvdc1命令扩容分区：" class="headerlink" title="2.8 使用resize2fs /dev/xvdc1命令扩容分区："></a>2.8 使用resize2fs /dev/xvdc1命令扩容分区：</h2><p>resize2fs /dev/vdb</p>
<p>vdb   vdb1 </p>
<p>[root@VM_0_17_centos /]# resize2fs /dev/vdb1</p>
<p>resize2fs 1.42.9 (28-Dec-2013)</p>
<p>Filesystem at /dev/vdb1 is mounted on /data; on-line resizing required</p>
<p>old_desc_blocks = 125, new_desc_blocks = 250</p>
<p>The filesystem on /dev/vdb1 is now 524287744 blocks long.</p>
<p>df -h</p>
<p>Filesystem      Size  Used Avail Use% Mounted on</p>
<p>/dev/vda1        50G  4.1G   43G   9% /</p>
<p>devtmpfs         16G     0   16G   0% /dev</p>
<p>tmpfs            16G   24K   16G   1% /dev/shm</p>
<p>tmpfs            16G  300K   16G   1% /run</p>
<p>tmpfs            16G     0   16G   0% /sys/fs/cgroup</p>
<p>/dev/vdb1       2.0T  150G  1.7T   8% /data</p>
<p>tmpfs           3.2G     0  3.2G   0% /run/user/0</p>
<h2 id="2-9-挂载-data盘，写入-etc-fstab"><a href="#2-9-挂载-data盘，写入-etc-fstab" class="headerlink" title="2.9  挂载/data盘，写入/etc/fstab"></a>2.9  挂载/data盘，写入/etc/fstab</h2><p> 不过做扩充时候是自动写进去的，重启过正常，数据没丢。。</p>
<p>cat /etc/fstab</p>
<p>/dev/vda1            /                    ext3       noatime,acl,user_xattr 1 1</p>
<p>proc                 /proc                proc       defaults              0 0</p>
<p>sysfs                /sys                 sysfs      noauto                0 0</p>
<p>debugfs              /sys/kernel/debug    debugfs    noauto                0 0</p>
<p>devpts               /dev/pts             devpts     mode=0620,gid=5       0 0</p>
<p>/dev/disk/bd/virtio-diskt1            /data                    ext4       defaults,nofail 0 1</p>
]]></content>
  </entry>
  <entry>
    <title>linux有足够内存还使用swap</title>
    <url>/2023/11/13/linux%E6%9C%89%E8%B6%B3%E5%A4%9F%E5%86%85%E5%AD%98%E8%BF%98%E4%BD%BF%E7%94%A8swap/</url>
    <content><![CDATA[<p>一台主机内存swap报警上去以查看确实swap快耗尽；</p>
<p>$free -m</p>
<p>&nbsp; total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shared&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;buff/cache&nbsp;&nbsp; available</p>
<p>Mem: 32012&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8293&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 243&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 594&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23475&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22638</p>
<p>Swap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7999&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7315&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 684</p>
<p>Linux starts swapping before the RAM is filled up. This is done to improve performance and responsiveness:</p>
<p>Performance is increased because sometimes RAM is better used for disk cache than to store program memory. So it’s better to swap out a program that’s been inactive for a while, and instead keep often-used files in cache.</p>
<p>Responsiveness is improved by swapping pages out when the system is idle, rather than when the memory is full and some program is running and requesting more RAM to complete a task.</p>
<p>Swapping does slow the system down, of course — but the alternative to swapping isn’t not swapping, it’s having more RAM or using less RAM.</p>
<p>翻译：Linux在物理内存用完之前使用swap，这样有助于提高系统性能和响应能力</p>
<p>1 性能可以提升的原因是：一些内存放磁盘缓存比方内存更合适。所以，最好交换出暂时不使用的内存，而把经常使用的文件放内存里面</p>
<p>2 提升响应能力通过，当系统空闲的时候swap page out，而不是当内存忙的时候，正在执行程序的时候执行swap</p>
<p>swaping确实会是系统性能下降，当然，通过swap可以有更多的可用内存</p>
<p>如何在有内存可用的时候，不使用swap呢？</p>
<p>This behaviour can be configured by setting the value of&nbsp;/proc/sys/vm/swappiness. The default value is 60, setting it to 0 means “never use swap when there is still RAM left“ and 100 is swapping out memory as soon as possible.</p>
<p>To change the value temporarily (lost on reboot):</p>
<p>sudo sysctl vm.swappiness=10<br>1.<br>To change the value permanently: Edit the file&nbsp;/etc/sysctl.conf&nbsp;as root (e.g.&nbsp;sudo nano /etc/sysctl.conf) and change the line&nbsp;vm.swapiness=…&nbsp;to the desired value.</p>
<p>There has been some debate on whether swapping out with free memory available is good or bad, but the Ubuntu help does indeed recommend a value of 10 for Desktop systems:&nbsp;<a href="https://help.ubuntu.com/community/SwapFaq">https://help.ubuntu.com/community/SwapFaq</a></p>
<p>centos swappiness配置的路径 &nbsp;/proc/sys/vm/swappiness</p>
<p>为什么不建议关闭swap</p>
<p>It is NOT recommended to turn off swap even if you have enough memory. If your server needs more memory and it did not get it, it will crash. However, this can be prevented (to some extent) when you have a swap area.</p>
<p>Yes, your server performance will degrade when using swap, but at least it will be operational and accessible. Then, you can plan for adding more memory when needed if your server starts using swap.</p>
<p>I found&nbsp;&nbsp;this page&nbsp;talking about swap. Have a look at 3rd section.</p>
<p>Instead of turning off swap, you can control the&nbsp;&nbsp;swapiness.</p>
<p>参考</p>
<p><a href="http://unix.stackexchange.com/questions/2658/why-use-swap-when-there-is-more-than-enough-ram">http://unix.stackexchange.com/questions/2658/why-use-swap-when-there-is-more-than-enough-ram</a></p>
<p>swap知识 &nbsp;<a href="https://help.ubuntu.com/community/SwapFaq">https://help.ubuntu.com/community/SwapFaq</a></p>
<p><a href="http://linux.cloudibee.com/2007/11/linux-performance-tuning-vm-swappiness/">http://linux.cloudibee.com/2007/11/linux-performance-tuning-vm-swappiness/</a></p>
<p>转载自:&nbsp;<a href="https://blog.csdn.net/wjciayf/article/details/79913381">https://blog.csdn.net/wjciayf/article/details/79913381</a></p>
<p>关于linux内存分配机制</p>
<p>在linux的内存分配机制中，优先使用物理内存，当物理内存还有空闲时（还够用），不会释放其占用内存，就算占用内存的程序已经被关闭了，该程序所占用的内存用来做缓存使用，对于开启过的程序、或是读取刚存取过得数据会比较快。</p>
<p>一．&nbsp;&nbsp;我们先来查看一个内存使用的例子：<br>[oracle@db1 ~]$ free -m<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; total&nbsp; &nbsp;&nbsp; &nbsp; used&nbsp; &nbsp;&nbsp;&nbsp; free&nbsp; &nbsp;&nbsp;&nbsp;shared&nbsp; &nbsp; buffers&nbsp;&nbsp;&nbsp;&nbsp;cached<br>Mem:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72433&nbsp; &nbsp;&nbsp;&nbsp;67075&nbsp; &nbsp;&nbsp;&nbsp;5357&nbsp; &nbsp;&nbsp; &nbsp;0&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;558&nbsp; &nbsp;&nbsp; &nbsp; 62221<br>-/+ buffers/cache:&nbsp;&nbsp;&nbsp;&nbsp;4295&nbsp; &nbsp;&nbsp; &nbsp;68138<br>Swap:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72096&nbsp; &nbsp;&nbsp; &nbsp;91&nbsp; &nbsp;&nbsp; &nbsp;72004<br>上述结果显示了67075M的used，但是（-/+ buffers/cache）减去buffers和cache的结果可以看到，所以当前进程实际占用内存是4296M。<br>可以这么理解：在linux的内存分配机制中，优先使用物理内存，当物理内存还有空闲时（还够用），不会释放其占用内存，就算占用内存的程序已经被关闭了，该程序所占用的内存用来做缓存使用，对于开启过的程序、或是读取刚存取过得数据会比较快。<br>如上面的例子：使用了72433M的内存，67075M被占用，但是buuffer和cached部分作为缓存，可以使用命中率的方式提高使用效率，而且这部分缓存是根据指令随时可以释放的，我们可以认为这部分内存没有实际被使用，也可以认为它是空闲的。<br>因此查看目前进程正在实际被使用的内存，是used-(buffers+cache)，也可以认为如果swap没有大量使用，mem还是够用的，只有mem被当前进程实际占用完（没有了buffers和cache），才会使用到swap的。</p>
<p>二．&nbsp;Swap配置对性能的影响<br>分配太多的Swap空间会浪费磁盘空间，而Swap空间太少，则系统会发生错误。如果系统的物理内存用光了，系统就会跑得很慢，但仍能运行；如果Swap空间用光了，那么系统就会发生错误。例如，Web服务器能根据不同的请求数量衍生出多个服务进程（或线程），如果Swap空间用完，则服务进程无法启动，通常会出现“application is out of memory”的错误，严重时会造成服务进程的死锁。因此Swap空间的分配是很重要的。<br>通常情况下，Swap空间应大于或等于物理内存的大小，最小不应小于64M，通常Swap空间的大小应是物理内存的2-2.5倍。但根据不同的应用，应有不同的配置：如果是小的桌面系统，则只需要较小的Swap空间，而大的服务器系统则视情况不同需要不同大小的Swap空间。特别是数据库服务器和Web服务器，随着访问量的增加，对Swap空间的要求也会增加，一般来说对于4G&nbsp;以下的物理内存，配置2倍的swap，4G&nbsp;以上配置1倍。<br>另外，Swap分区的数量对性能也有很大的影响。因为Swap交换的操作是磁盘IO的操作，如果有多个Swap交换区，Swap空间的分配会以轮流的方式操作于所有的Swap，这样会大大均衡IO的负载，加快Swap交换的速度。如果只有一个交换区，所有的交换操作会使交换区变得很忙，使系统大多数时间处于等待状态，效率很低。用性能监视工具就会发现，此时的CPU并不很忙，而系统却慢。这说明，瓶颈在IO上，依靠提高CPU的速度是解决不了问题的。</p>
<p>三.&nbsp;&nbsp;Linux&nbsp;内存机制<br>Linux支持虚拟内存(VirtualMmemory)，虚拟内存是指使用磁盘当作RAM的扩展，这样可用的内存的大小就相应地增大了。内核会将暂时不用的内存块的内容写到硬盘上，这样一来，这块内存就可用于其它目的。当需要用到原始的内容时，它们被重新读入内存。这些操作对用户来说是完全透明的;Linux下运行的程序只是看到有大量的内存可供使用而并没有注意到时不时它们的一部分是驻留在硬盘上的。当然，读写硬盘要比直接使用真实内存慢得多(要慢数千倍)，所以程序就不会象一直在内存中运行的那样快。用作虚拟内存的硬盘部分被称为交换空间(Swap Space)。<br>一般，在交换空间中的页面首先被换入内存;如果此时没有足够的物理内存来容纳它们又将被交换出来(到其他的交换空间中)。如果没有足够的虚拟内存来容纳所有这些页面，Linux就会波动而不正常;但经过一段较长的时间Linux会恢复，但此时系统已不可用了。<br>有时，尽管有许多的空闲内存，仍然会有许多的交换空间正被使用。这种情况是有可能发生的，例如如果在某一时刻有进行交换的必要，但后来一个占用很多物理内存的大进程结束并释放内存时。被交换出的数据并不会自动地交换进内存，除非有这个需要时。此时物理内存会在一段时间内保持空闲状态。对此并没有什么可担心的，但是知道了是怎么一回事，也就无所谓了。<br>许多操作系统使用了虚拟内存的方法。因为它们仅在运行时才需要交换空间，以解决不会在同一时间使用交换空间，因此，除了当前正在运行的操作系统的交换空间，其它的就是一种浪费。所以让它们共享一个交换空间将会更有效率。<br>注意：如果会有几个人同时使用这个系统，他们都将消耗内存。然而，如果两个人同时运行一个程序，内存消耗的总量并不是翻倍，因为代码页以及共享的库只存在一份。</p>
<p>Linux系统常常动不动就使用交换空间，以保持尽可能多的空闲物理内存。即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间：当磁盘闲着，就可以提前做好交换。可以将交换空间分散在几个硬盘之上。针对相关磁盘的速度以及对磁盘的访问模式，这样做可以提高性能。</p>
<p>与访问物理内存相比，磁盘的读写是很慢的。另外，在相应较短的时间内多次读磁盘同样的部分也是常有的事。例如，某人也许首先阅读了一段E-mail消息，然后为了答复又将这段消息读入编辑器中，然后又在将这个消息拷贝到文件夹中时，使得邮件程序又一次读入它。或者考虑一下在一个有着许多用户的系统中&nbsp;ls命令会被使用多少次。通过将信息从磁盘上仅读入一次并将其存于内存中，除了第一次读以外，可以加快所有其它读的速度。这叫作磁盘缓冲(Disk Buffering)，被用作此目的的内存称为高速缓冲(Buffer Cache)。但是，由于内存是一种有限而又不充足的资源，高速缓冲不可能做的很大(它不可能包容要用到的所有数据)。当缓冲充满了数据时，其中最长时间不用的数据将被舍弃以腾出内存空间用于新的数据。</p>
<p>对写磁盘操作来说磁盘缓冲技术同样有效。一方面，被写入磁盘的数据常常会很快地又被读出(例如，原代码文件被保存到一个文件中，又被编译器读入)，所以将要被写的数据放入缓冲中是个好主意。另一方面，通过将数据放入缓冲中，而不是将其立刻写入磁盘，程序可以加快运行的速度。以后，写的操作可以在后台完成，而不会拖延程序的执行。<br>大多数操作系统都有高速缓冲(尽管可能称呼不同)，但是并不是都遵守上面的原理。有些是直接写(Write-Through)：数据将被立刻写入磁盘(当然，数据也被放入缓存中)。如果写操作是在以后做的，那么该缓存被称为后台写(Write-Back)。后台写比直接写更有效，但也容易出错：如果机器崩溃，或者突然掉电，缓冲中改变过的数据就被丢失了。如果仍未被写入的数据含有重要的薄记信息，这甚至可能意味着文件系统(如果有的话)已不完整。<br>针对以上的原因，出现了很多的日志文件系统，数据在缓冲区修改后，同时会被文件系统记录修改信息，这样即使此时系统掉电，系统重启后会首先从日志记录中恢复数据，保证数据不丢失。当然这些问题不再本文的叙述范围。<br>由于上述原因，在使用适当的关闭过程之前，绝对不要关掉电源，Sync命令倾空(Flushes)缓冲，也即，强迫所有未被写的数据写入磁盘，可用以确定所有的写操作都已完成。在传统的UNIX系统中，有一个叫做update的程序运行于后台，每隔30秒做一次sync操作，因此通常无需手工使用sync命令了。Linux另外有一个后台程序，Bdflush，这个程序执行更频繁的但不是全面的同步操作，以避免有时sync的大量磁盘I/O操作所带来的磁盘的突然冻结。<br>在Linux中，Bdflush是由update启动的。通常没有理由来担心此事，但如果由于某些原因bdflush进程死掉了，内核会对此作出警告，此时你就要手工地启动它了(/sbin/update)。</p>
<p>缓存(Cache)实际并不是缓冲文件的，而是缓冲块的，块是磁盘I/O操作的最小单元(在Linux中，它们通常是1KB)。这样，目录、超级块、其它文件系统的薄记数据以及非文件系统的磁盘数据都可以被缓冲了。缓冲的效力主要是由它的大小决定的。缓冲太小的话等于没用。它只能容纳一点数据，因此在被重用时，所有缓冲的数据都将被倾空。实际的大小依赖于数据读写的频次、相同数据被访问的频率。只有用实验的方法才能知道。<br>如果缓存有固定的大小，那么缓存太大了也不好，因为这会使得空闲的内存太小而导致进行交换操作(这同样是慢的)。为了最有效地使用实际内存，Linux自动地使用所有空闲的内存作为高速缓冲，当程序需要更多的内存时，它也会自动地减小缓冲的大小。&nbsp;<br>这就是一般情况下Linux内存的一般机制，真正的Linux内存的运行机制远远比这个复杂。</p>
<p>&nbsp;</p>
<p>Other：</p>
<p>swap tendency = mapped ratio / 2 + distress + swappiness</p>
<p>The mapped ratio value is the percentage of pages in all memory zones thatbelong to User Mode address spaces (sc-&gt;nr_mapped) with respect to the totalnumber of allocatable page frames. A high value of mapped_ratio means that thedynamic memory is mostly used by User Mode processes, while a low value meansthat it is mostly used by the page cache.</p>
<p>The distress value is a measure of how effectively the PFRA is reclaiming pageframes in this zone; it is based on the scanning priority of the zone in theprevious run of the PFRA, which is stored in the prev_priority field of thezone descriptor. The distress value depends on the zone’s previous priority asfollows:</p>
<p>Zone prev. priority<br>12…7<br>6<br>5<br>4<br>3<br>2<br>1<br>0</p>
<p>Distress value<br>0<br>1<br>3<br>6<br>12<br>25<br>50<br>100<br>Finally, the swappiness value is a user-defined constant, which is usually setto 60. The system administrator may tune this value by writing in the/proc/sys/vm/swappiness file or by issuing the proper sysctl( ) system call.</p>
<p>Pages will be reclaimed from the address spaces of processes only if the zone’sswap tendency is greater than or equal to 100. Thus, if the systemadministrator sets swappiness to 0, then the PFRA never reclaims pages in theUser Mode address spaces unless the zone’s previous priority is zero (anunlikely event); if the administrator sets swappiness to 100, then the PFRAreclaims pages in the User Mode address spaces at every invocation.<br>swappiness，吃参数是得到swap tendency的一个量，而swap tendency是linux内核进行内存进行回收的一个阀值和标量。</p>
<p><a href="https://blog.csdn.net/ly890700/article/details/73695750">https://blog.csdn.net/ly890700/article/details/73695750</a></p>
<p>首先是,kswapd进程来定期扫描系统资源,查看内存是否够用,由两个值影响pages_high和page_low,如果现在可使用的区间在page_high&lt;x&lt;page_low,就开始检查从文件系统读入的文件,有无被修改的内存页面,如果有就写入到磁盘,但是,如果内存页面被修改了,有可能不是从文件系统读入的,即找不到回写的位置,如malloc产生的anonymous内存数据就写入swap分区,这部分当进程在次被唤醒,获得了CPU运行时间,在从swap读入。</p>
<p>swappiness的值的大小对如何使用swap分区是有着很大的联系的。swappiness=0的时候表示最大限度使用物理内存，然后才是swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。linux的基本默认设置为60，具体如下：</p>
<p>cat /proc/sys/vm/swappiness<br>#60</p>
<p>也就是说，你的内存在使用到100-60=40%的时候，就开始出现有交换分区的使用。大家知道，内存的速度会比磁盘快很多，这样子会加大系统IO，同时造的成大量页的换进换出，严重影响系统的性能，所以我们在操作系统层面，要尽可能使用内存，对该参数进行调整。</p>
<p>临时调整的方法如下，我们调成10：</p>
<p>sysctl vm.swappiness=10<br>#vm.swappiness=10</p>
<p>cat /proc/sys/vm/swappiness</p>
<p>#10</p>
<p>这只是临时调整的方法，重启后会回到默认设置的.</p>
<p>要想永久调整的话，需要在/etc/sysctl.conf修改，加上：</p>
<p>sudo vim /etc/sysctl.conf</p>
<p>加上</p>
<h1 id="Controls-the-maximum-number-of-shared-memory-segments-in-pages"><a href="#Controls-the-maximum-number-of-shared-memory-segments-in-pages" class="headerlink" title="Controls the maximum number of shared memory segments, in pages"></a>Controls the maximum number of shared memory segments, in pages</h1><p>kernel.shmall = 4294967296 #这一个可以不用设置</p>
<p>vm.swappiness = 10</p>
<p>&nbsp;生效</p>
<p>sudo sysctl -p</p>
<p>这样便完成修改设置！</p>
<p>&nbsp;</p>
<p>Ps在服务器内存充裕的情况下尽量用内存，swap缓存设置低一些，使用swap是必要的；</p>
<p>另外：swap可以扩充的，但是会不会影响线上业务，或者使用sysctl vm.swappiness=10命令时候会不会影响线上业务，一直纠结中。</p>
<p>&nbsp;</p>
<p>转自：<a href="https://www.cnblogs.com/EasonJim/p/7777904.html">https://www.cnblogs.com/EasonJim/p/7777904.html</a></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;用文件增加swap：</p>
<p>dd if=/dev/zero of=/tmp/swapadd bs=1024 count=2048000&nbsp; &nbsp; ###添加一块2G的swap文件</p>
<p>mkswap /tmp/swapadd&nbsp; ####格式化文件</p>
<p>swapon /tmp/swapadd ###增加swap</p>
<p>free -m</p>
<p>echo “/tmp/swapadd swap swap defaults 0 0” &gt;&gt; /etc/fstab&nbsp; &nbsp; ###开机自动挂载swap分区</p>
<p>swapoff swapadd&nbsp; ###&nbsp;使用Swapoff命令收回Swap空间</p>
<p>rm swapadd&nbsp;&nbsp; &nbsp;###从文件系统中回收此文件</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>php 安装redis，protobuf,mcryp扩展</title>
    <url>/2023/11/10/php-%E5%AE%89%E8%A3%85redis%EF%BC%8Cprotobuf-mcryp%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>&nbsp; 测试机上测试一些数据需要用到redis扩展，偷懒yum安装的php，以前yum install php-pecl-redis.x86_64可以安装扩展，这次找不到安装包，不折腾手动安装下。</p>
<p>1.下载phpredis</p>
<p>cd /usr/local/src</p>
<p>wget <a href="https://github.com/nicolasff/phpredis/archive/2.2.4.tar.gz">https://github.com/nicolasff/phpredis/archive/2.2.4.tar.gz</a></p>
<p>tar -zxvf 2.2.4.tar.gz</p>
<p>cd phpredis-2.2.4/</p>
<p>2.用phpize生成configure配置文件</p>
<p>/usr/bin/phpize&nbsp; #会生成几个新文件，默认安装路径自定义的按照自定义路径；</p>
<p>./configure –with-php-config=/usr/bin/php-config</p>
<p>make #编译</p>
<p>make install #安装</p>
<p>make test #测试</p>
<p>3.配置php支持</p>
<p>vim /usr/local/php/etc/php.ini #编辑配置文件，在最后一行添加以下内容</p>
<p>extension=”redis.so”</p>
<ol start="4">
<li></li>
</ol>
<p>重启http加载查看phpinfo信息：</p>
<p>redis</p>
<p>Redis Supportenabled</p>
<p>Redis Version2.2.4</p>
<p>成功！</p>
<p>php扩展Protobuf</p>
<p>下载protobuf扩展包：wget <a href="https://github.com/allegro/php-protobuf/archive/master.zip%E8%BF%99%E4%B8%AAmaster.zip%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%9B">https://github.com/allegro/php-protobuf/archive/master.zip这个master.zip会报错；</a></p>
<p>master.zip</p>
<p>cd /home/tools/php-protobuf-master/</p>
<p>phpize</p>
<p>可能会报错php-devel</p>
<p>yum install php-devel</p>
<p>./configure<br>1.<br>make&nbsp;&amp;&amp;&nbsp;make&nbsp;install<br>1.</p>
<p>If you ever happen to want to link against installed libraries</p>
<p>in a given directory, LIBDIR, you must either use libtool, and</p>
<p>specify the full pathname of the library, or use the `-LLIBDIR’</p>
<p>flag during linking and do at least one of the following:</p>
<p>&nbsp;&nbsp; - add LIBDIR to the `LD_LIBRARY_PATH’ environment variable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; during execution</p>
<p>&nbsp;&nbsp; - add LIBDIR to the `LD_RUN_PATH’ environment variable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; during linking</p>
<p>&nbsp;&nbsp; - use the `-Wl,-rpath -Wl,LIBDIR’ linker flag</p>
<p>&nbsp;&nbsp; - have your system administrator add LIBDIR to `/etc/ld.so.conf’</p>
<p>&nbsp;</p>
<p>See any operating system documentation about shared libraries for</p>
<p>more information, such as the ld(1) and ld.so(8) manual pages.</p>
<hr>
<p>&nbsp;</p>
<p>Build complete.</p>
<p>Don’t forget to run ‘make test’.</p>
<p>&nbsp;</p>
<p>Installing shared extensions:&nbsp;&nbsp;&nbsp;&nbsp; /usr/lib64/php/modules/</p>
<p>然后再php.ini增加</p>
<p>extension = protocolbuffers.so</p>
<p>重启下http就可以了；</p>
<p>装载protobuff库：</p>
<p>&nbsp;pear&nbsp;channel-discover&nbsp;pear.pollinimini.net&nbsp;</p>
<p>pear&nbsp;install&nbsp;drslump/Protobuf-beta&nbsp;</p>
<p>mcryp扩展：</p>
<p>yum install libmcrypt libmcrypt-devel mcrypt mhash 如果报错找不到补丁的话手动安装；</p>
<p>下载Libmcrypt,mhash,mcrypt安装包</p>
<p>Libmcrypt(libmcrypt-2.5.8.tar.gz)：<a href="http://sourceforge.net/project/showfiles.php?group_id=87941&amp;package_id=91774&amp;release_id=487459">http://sourceforge.net/project/showfiles.php?group_id=87941&amp;package_id=91774&amp;release_id=487459</a></p>
<p>mcrypt(mcrypt-2.6.8.tar.gz ):<a href="http://sourceforge.net/project/showfiles.php?group_id=87941&amp;package_id=91948&amp;release_id=642101">http://sourceforge.net/project/showfiles.php?group_id=87941&amp;package_id=91948&amp;release_id=642101</a></p>
<p>mhash(mhash-0.9.9.9.tar.gz):<a href="http://sourceforge.net/project/showfiles.php?group_id=4286&amp;package_id=4300&amp;release_id=645636">http://sourceforge.net/project/showfiles.php?group_id=4286&amp;package_id=4300&amp;release_id=645636</a></p>
<p>2.先安装Libmcrypt</p>
<p>tar -zxvf libmcrypt-2.5.8.tar.gz</p>
<p>cd libmcrypt-2.5.8</p>
<p>./configure</p>
<p>make</p>
<p>make install</p>
<p>说明：libmcript默认安装在/usr/local&nbsp;</p>
<p>3.再安装mhash</p>
<p>tar -zxvf mhash-0.9.9.9.tar.gz</p>
<p>cd mhash-0.9.9.9</p>
<p>./configure</p>
<p>make &amp;&amp; make install</p>
<p>4.最后安装mcrypt</p>
<p>tar -zxvf mcrypt-2.6.8.tar.gz</p>
<p>cd mcrypt-2.6.8</p>
<p>LD_LIBRARY_PATH=/usr/local/lib ./configure</p>
<p>make &amp;&amp; make install</p>
<p>说明：由于在配置Mcrypt时，会找不到libmcrypt的链接库，导致无法编译，因为Libmcrypt的链接库在/usr/local/lib文件夹下。</p>
<p>因次，在配置mcrypt时要加入LD_LIBRARY_PATH=/usr/local/lib导入键接库。</p>
<p>到&nbsp;<a href="http://cn.php.net/releases/">http://cn.php.net/releases/</a>&nbsp;网页下找到自己对应php版本，下载后解压</p>
<p>cd php-5.4.16/ext/mcrypt/</p>
<p>phpize (执行phpize命令（phpize是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块，如果没有？yum install php-devel)</p>
<p>phpize&nbsp;</p>
<p>Configuring for:</p>
<p>PHP Api Version:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;20100412</p>
<p>Zend Module Api No:&nbsp; &nbsp; &nbsp; 20100525</p>
<p>Zend Extension Api No:&nbsp; &nbsp;220100525</p>
<p>yum 安装php./configure就可以，定制的需要自己的路径如比：./configure –with-php-config=/usr/bin/php-config</p>
<p>./configure</p>
<p>make &amp;&amp; make install</p>
<p>Libraries have been installed in:</p>
<p>&nbsp; &nbsp;/home/tools/php-5.4.16/ext/mcrypt/modules</p>
<p>If you ever happen to want to link against installed libraries</p>
<p>in a given directory, LIBDIR, you must either use libtool, and</p>
<p>specify the full pathname of the library, or use the `-LLIBDIR’</p>
<p>flag during linking and do at least one of the following:</p>
<p>&nbsp; &nbsp;- add LIBDIR to the `LD_LIBRARY_PATH’ environment variable</p>
<p>&nbsp; &nbsp; &nbsp;during execution</p>
<p>&nbsp; &nbsp;- add LIBDIR to the `LD_RUN_PATH’ environment variable</p>
<p>&nbsp; &nbsp; &nbsp;during linking</p>
<p>&nbsp; &nbsp;- use the `-Wl,-rpath -Wl,LIBDIR’ linker flag</p>
<p>&nbsp; &nbsp;- have your system administrator add LIBDIR to `/etc/ld.so.conf’</p>
<p>See any operating system documentation about shared libraries for</p>
<p>more information, such as the ld(1) and ld.so(8) manual pages.</p>
<hr>
<p>Build complete.</p>
<p>Don’t forget to run ‘make test’.</p>
<p>Installing shared extensions:&nbsp; &nbsp; &nbsp;/usr/lib64/php/modules/</p>
<p>php.ini添加一条extension=mcrypt.so</p>
<p>extension = protocolbuffers.so</p>
<p>extension = mcrypt.so</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>ssh免密登录问题</title>
    <url>/2023/11/13/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一台内网多个开发公用服务器，各自用户对对应的a，b台服务器做过免密登录，一直很好用，突然不能用了；追缘由以前的服务器多用户感觉吃力太慢，于是乎换了一台高配服务器，开发省事直接把原来的公钥给复制过来了，倒也是相安无事，前几天小伙伴处理服务器c免密，把公钥重新生成了，覆盖了原来的文件，vim&nbsp;id_rsa.pub 复制到服务器上面的，结果，开发a.b服务器不能免密了，处理的c服务器也不能免密登录；开发的a,b服务器因为公钥改了导致，c服务器检查了sshd_conf和authorized_keys以后，vim&nbsp;id_rsa.pub贴上去的内容有问题，so还是&nbsp;scp id_rsa.pub root@B:~/id_rsa.pub，然后登录b服务器cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys这样安全些。</p>
<p>免密登录出问题：&nbsp;1.sshd_conf 配置检查；</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.id_rsa.pub变动；</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.查看authorized_keys；</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.权限问题 ：.ssh目录下的authorized_keys文件需要600或644权限</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.&nbsp;StrictModes问题编辑sudo vi /etc/ssh/sshd_config，找到#StrictModes yes改成StrictModes no</p>
<p>服务器A需要免密码访问服务器B：</p>
<ol>
<li>在A上面生成公钥密钥，执行命令</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;ssh-keygen -t rsa 或者 ssh-keygen -t rsa -P ‘’</p>
<p>一路回车即可，会在~/.ssh目录下生成 id_rsa和id_rsa.pub两个文件，id_rsa为私钥，id_rsa.pub为公钥</p>
<ol start="2">
<li>将公钥id_rsa.pub拷贝到B机器上</li>
</ol>
<p>&nbsp;scp id_rsa.pub root@B:~/id_rsa.pub</p>
<ol start="3">
<li>在服务器B对应的用户root/.ssh下面将id_rsa.pub追加到~/.ssh/authorized_keys文件中</li>
</ol>
<p>cd&nbsp;/home/user/.ssh</p>
<p>cat id_rsa.pub &gt;&gt; authorized_keys&nbsp; 注意是&gt;&gt;别覆盖了；</p>
<ol start="4">
<li>设置 authorized_keys权限</li>
</ol>
<p>&nbsp;chmod 600 ~/.ssh/authorized_keys</p>
<hr>
]]></content>
  </entry>
</search>
